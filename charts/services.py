from django.db.models import Avg, Count, Sum
from django.db.models.functions import ExtractYear, Lower, Trim, Upper
from .models import Attack, Breach, Vulnerability


class DataProcessor(object):
    @staticmethod
    def get_line_chart_data():
        xAxis, series = BreachData.get_individuals_affected_data()
        data = {}
        data['title'] = 'Individuals affected by breaches'
        data['xAxis'] = xAxis
        data['yAxis'] = 'Individuals'
        data['series'] = series
        return data

    @staticmethod
    def get_area_chart_data():
        xAxis, series = AttackData.get_protocols_per_category_data()
        data = {}
        data['title'] = 'Protocols used per Attack Categories'
        data['xAxis'] = xAxis
        data['yAxis'] = 'Attack Categories'
        data['series'] = series
        return data

    @staticmethod
    def get_column_chart_data():
        series = VulnerabilityData.get_vulnerabilities_score_data()
        data = {}
        data['title'] = 'Severity score of vulnerabilities'
        data['xAxis'] = 'category'
        data['yAxis'] = 'Score'
        data['series'] = series
        return data

    @staticmethod
    def get_multi_column_chart_data():
        xAxis, series = VulnerabilityData\
                        .get_access_and_confidentiality_impact_data()
        data = {}
        data['title'] = "Confidentiality impact in contrast with access\
                         complexity"
        data['xAxis'] = xAxis
        data['yAxis'] = 'Impacts'
        data['series'] = series
        return data

    @staticmethod
    def get_stacked_column_chart_data():
        xAxis, series = VulnerabilityData\
                        .get_access_and_integrity_impact_data()
        data = {}
        data['title'] = "Integrity impact in contrast with access\
                         complexity"
        data['xAxis'] = xAxis
        data['yAxis'] = 'Impacts'
        data['series'] = series
        return data

    @staticmethod
    def get_pie_chart_data():
        series = BreachData.get_location_breached_info_data()
        data = {}
        data['title'] = 'Location of breached information'
        data['series'] = series
        return data


class AttackData(object):
    @staticmethod
    def get_protocols_per_category_data():
        categories_qs = Attack.objects.values('category').distinct()
        categories = [qe['category'].strip() for qe in categories_qs]
        categories = sorted(list(set(categories)))

        protocols_qs = Attack.objects.values('protocol').distinct()
        protocols = [qe['protocol'].strip().upper() for qe in protocols_qs]
        protocols = sorted(list(set(protocols)))

        categ_proto_qs = Attack.objects.annotate(
                                          p_category=Trim('category'),
                                          p_protocol=Upper(Trim('protocol')))\
                                       .values('p_category', 'p_protocol')\
                                       .annotate(counter=Count('protocol'))
        categ_proto = {category: dict.fromkeys(protocols, 0)
                       for category in categories}
        for qe in categ_proto_qs:
            categ_proto[qe['p_category']][qe['p_protocol']] += qe['counter']

        series = []
        for category in categories:
            element = {}
            element['name'] = category
            element['data'] = []
            for protocol in protocols:
                element['data'].append(categ_proto[category][protocol])
            series.append(element)
        return protocols, series


class BreachData(object):
    @staticmethod
    def get_individuals_affected_data():
        years_qs = Breach.objects.annotate(year=ExtractYear('date_created'))\
                                 .values('year').distinct()
        years = sorted([qe['year'] for qe in years_qs])

        breach_types_qs = Breach.objects.values('breach_type').distinct()
        breach_types = [breach_type.strip()
                        for qe in breach_types_qs
                        for breach_type in qe['breach_type'].split(',')]
        breach_types = sorted(list(set(breach_types)))

        indiv_affec_qs = Breach.objects.annotate(
                                    p_breach_type=Trim('breach_type'),
                                    p_year=ExtractYear('date_created'),)\
                               .values('p_breach_type', 'p_year')\
                               .annotate(total=Sum('individuals_affected'))
        indiv_affec = {breach_type: dict.fromkeys(years, 0)
                       for breach_type in breach_types}
        for qe in indiv_affec_qs:
            for breach_type in qe['p_breach_type'].split(','):
                indiv_affec[breach_type.strip()][qe['p_year']] += qe['total']

        series = []
        for breach_type in breach_types:
            element = {}
            element['name'] = breach_type
            element['data'] = []
            for year in years:
                element['data'].append(indiv_affec[breach_type][year])
            series.append(element)

        return years, series

    @staticmethod
    def get_location_breached_info_data():
        loc_bre_info_qs = Breach.objects.annotate(
                                    p_location=Lower(
                                        Trim('location_of_breached_info')))\
                                .values('p_location')\
                                .annotate(
                                    total=Count('location_of_breached_info'))

        loc_bre_info_keys = [
            location.strip().capitalize()
            for qe in loc_bre_info_qs
            for location in qe['p_location'].split(',')]
        loc_bre_info_keys = list(set(loc_bre_info_keys))
        loc_bre_info = {key: 0 for key in loc_bre_info_keys}
        for qe in loc_bre_info_qs:
            for key in qe['p_location'].split(','):
                loc_bre_info[key.strip().capitalize()] += qe['total']

        series = {
            'name': 'Brands',
            'colorByPoint': True,
            'data': []
        }

        for key in sorted(loc_bre_info_keys):
            series['data'].append({
                'name': key,
                'y': loc_bre_info[key]
            })

        return [series]


class VulnerabilityData(object):
    @staticmethod
    def get_vulnerabilities_score_data():
        vuln_score_qs = Vulnerability.objects.annotate(
                                            p_name=Trim('name'))\
                                      .values('p_name')\
                                      .annotate(average=Avg('score'))

        series = {}
        series['name'] = "Vulnerabilities"
        series['colorByPoint'] = True
        series['data'] = [{'name': qe['p_name'], 'y': qe['average']}
                          for qe in vuln_score_qs]

        return [series]

    @staticmethod
    def get_access_and_confidentiality_impact_data():
        access_values = ['NONE', 'LOW', 'MEDIUM', 'HIGH']
        impact_values = ['NONE', 'PARTIAL', 'COMPLETE']
        confi_qs = Vulnerability.objects.filter(
                                    access_complexity__in=(
                                        tuple(access_values)),
                                    impact_confidentiality__in=(
                                        tuple(impact_values)))\
                                .values(
                                    'access_complexity',
                                    'impact_confidentiality')\
                                .annotate(
                                    total=Count('impact_confidentiality'))

        impact_confi = {access_value: dict.fromkeys(impact_values, 0)
                        for access_value in access_values}

        for qe in confi_qs:
            key1 = qe['access_complexity']
            key2 = qe['impact_confidentiality']
            impact_confi[key1][key2] += qe['total']

        series = []

        for impact in impact_values:
            element = {}
            element['name'] = f'{impact} (Impact)'
            element['data'] = []
            for access in access_values:
                element['data'].append(impact_confi[access][impact])
            series.append(element)

        labels = list(map(lambda x: f'Access Complexity: {x}', access_values))

        return labels, series

    @staticmethod
    def get_access_and_integrity_impact_data():
        access_values = ['NONE', 'LOW', 'MEDIUM', 'HIGH']
        impact_values = ['NONE', 'PARTIAL', 'COMPLETE']
        integ_qs = Vulnerability.objects.filter(
                                    access_complexity__in=(
                                        tuple(access_values)),
                                    impact_integrity__in=(
                                        tuple(impact_values)))\
                                .values(
                                    'access_complexity',
                                    'impact_integrity')\
                                .annotate(
                                    total=Count('impact_integrity'))

        impact_integ = {access_value: dict.fromkeys(impact_values, 0)
                        for access_value in access_values}

        for qe in integ_qs:
            key1 = qe['access_complexity']
            key2 = qe['impact_integrity']
            impact_integ[key1][key2] += qe['total']

        series = []

        for impact in impact_values:
            element = {}
            element['name'] = f'{impact} (Impact)'
            element['data'] = []
            for access in access_values:
                element['data'].append(impact_integ[access][impact])
            series.append(element)

        labels = list(map(lambda x: f'Access Complexity: {x}', access_values))

        return labels, series
